{% extends 'base.html' %} {% load static %} {% block content %}

<form action="" id="myForm" enctype="multipart/form-data">
    {% csrf_token %}
  <div class="left">
    <div id="startButton" class="button">Start</div>
    <h2>Preview</h2>
    <video id="preview" width="160" height="120" autoplay muted></video>
  </div>

  <div class="right">
    <div id="stopButton" class="button">Stop</div>
    <h2>Recording</h2>
    <video id="recording" width="160" height="120" controls></video>
    <a id="downloadButton" class="button"> Download </a>
  </div>
</form>

<script>
  let preview = document.getElementById("preview");
  let recording = document.getElementById("recording");
  let startButton = document.getElementById("startButton");
  let stopButton = document.getElementById("stopButton");
  let downloadButton = document.getElementById("downloadButton");
  let logElement = document.getElementById("log");
  let myForm = document.getElementById("myForm");
  let recordingTimeMS = 5000;
  let recordedBlob;

  function log(msg) {
    //logElement.innerHTML += msg + "\n";
  }

  function wait(delayInMS) {
    return new Promise((resolve) => setTimeout(resolve, delayInMS));
  }

  function startRecording(stream, lengthInMS) {
    let recorder = new MediaRecorder(stream);
    let data = [];

    recorder.ondataavailable = (event) => data.push(event.data);
    recorder.start();
    log(recorder.state + " for " + lengthInMS / 1000 + " seconds...");

    let stopped = new Promise((resolve, reject) => {
      recorder.onstop = resolve;
      recorder.onerror = (event) => reject(event.name);
    });

    let recorded = wait(lengthInMS).then(
      () => recorder.state == "recording" && recorder.stop()
    );

    return Promise.all([stopped, recorded]).then(() => data);
  }

  function stop(stream) {
    stream.getTracks().forEach((track) => track.stop());
  }

  startButton.addEventListener(
    "click",
    function () {
      navigator.mediaDevices
        .getUserMedia({
          video: true,
          audio: false,
        })
        .then((stream) => {
          preview.srcObject = stream;
          downloadButton.href = stream;
          preview.captureStream =
            preview.captureStream || preview.mozCaptureStream;
          return new Promise((resolve) => (preview.onplaying = resolve));
        })
        .then(() => startRecording(preview.captureStream(), recordingTimeMS))
        .then((recordedChunks) => {
          recordedBlob = new Blob(recordedChunks, { type: "video/webm" });
          console.log(recordedBlob);
          recording.src = URL.createObjectURL(recordedBlob);

          downloadButton.href = recording.src;
          downloadButton.download = "RecordedVideo.mp4";

          log(
            "Successfully recorded " +
              recordedBlob.size +
              " bytes of " +
              recordedBlob.type +
              " media."
          );
        })
        .catch(log);
    },
    false
  );

  stopButton.addEventListener(
    "click",
    function () {
      stop(preview.srcObject);
    },
    false
  );

  downloadButton.addEventListener("click", (e) => {
    e.preventDefault();
    const endpt = "upload";
    const formData = new FormData();
    console.log(recordedBlob);
    formData.append("video", recordedBlob);
    
    fetch(endpt, {
      method: "POST", 
      body: formData,
      headers: new Headers({'content-type': 'video/webm'}),
    }).catch(log);
  });
</script>

{% endblock content %}
